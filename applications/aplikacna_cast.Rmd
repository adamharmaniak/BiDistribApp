---
title: "Modelling joint probability distribution of
a mixture of continuous and categorical
random variables"
author: "Adam Harmaniak"
date: "2025-02-21"
output: html_document
---

# Dokumentacia


# Pouzite kniznice

```{r,warning=FALSE}
suppressMessages(suppressWarnings({
  library(ggplot2)
  library(plotly)
  library(copula)
  library(patchwork)
  library(dplyr)
  library(tibble)
  library(MASS)
  library(randomForest)
  library(mgcv)
  library(ks)
  library(tidyr)
}))

```

# Identifikacia a vypis premennych

```{r, warning=FALSE}
identify_variables <- function(data) {
  variable_types <- sapply(data, function(col) {
    if (is.factor(col) || is.character(col) || (is.numeric(col) && length(unique(col)) < 10)) {
      return("Diskretna")
    } else {
      return("Spojita")
    }
  })
  
  discrete_vars <- names(variable_types[variable_types == "Diskretna"])
  continuous_vars <- names(variable_types[variable_types == "Spojita"])
  
  return(list(Diskretne = discrete_vars, Spojite = continuous_vars))
}
```

```{r, warning=FALSE}
data <- mtcars
num_variables <- length(colnames(data))
variables <- identify_variables(data)

table_result <- tibble(
  Index = seq_len(num_variables),
  Variable_Name = c(variables$Diskretne, variables$Spojite),
  Variable_Type = c(rep("Diskrétna", length(variables$Diskretne)), rep("Spojitá", length(variables$Spojite)))
)

print(table_result)
```

# Funkcia na modelovanie zdruzenej hustoty 1 spojitej a 1 diskretnej nahodnej premennej

```{r, warning=FALSE}
model_mixture_joint_distribution <- function(data, selected_variables, model_type) {
  # Identifikacia typov premennych
  variable_types <- identify_variables(data)
  discrete_vars <- intersect(variable_types$Diskretne, selected_variables)
  continuous_vars <- intersect(variable_types$Spojite, selected_variables)
  
  if(length(selected_variables) != 2 || length(discrete_vars) == 0 || length(continuous_vars) == 0) {
    stop("Zoznam premennych musi obsahovat prave 1 spojitu a 1 diskretnu premennu!")
  }
  
  # Modelovanie hustoty ako hustoty normalneho rozdelenia (dnorm)
  if (model_type == "normal") {
    # Konverzia diskretnej premennej na faktor a zoradenie kategorii
    data[[discrete_vars]] <- factor(data[[discrete_vars]])
    categories <- levels(data[[discrete_vars]])
    
    # Definovanie farebnej škály pre konzistentnosť
    color_palette <- RColorBrewer::brewer.pal(length(categories), "Set1")
    names(color_palette) <- categories
    
    # Vypocet hustoty pre kazdu kategoriu
    calculate_density_3D <- function(data, category) {
      sub_data <- filter(data, .data[[discrete_vars]] == category)
      if (nrow(sub_data) > 1) {
        mu <- mean(sub_data[[continuous_vars]])
        sigma <- sd(sub_data[[continuous_vars]])
        x <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
        density <- dnorm(x, mean = mu, sd = sigma)
        return(data.frame(Weight = x, Density = density, Age_Category = factor(category, levels = categories)))
      } else {
        return(data.frame(Weight = numeric(0), Density = numeric(0), Age_Category = factor(character(0), levels = categories)))
      }
    }

    # Spojenie hustot pre vsetky kategorie
    density_data <- bind_rows(lapply(categories, function(cat) calculate_density_3D(data, cat)))

    # Vizualizacia v 3D
    fig_3d <- plot_ly(density_data, x = ~Weight, y = ~Age_Category, z = ~Density, 
                       type = 'scatter3d', mode = 'lines', 
                       color = ~Age_Category, colors = color_palette, line = list(width = 4)) %>%
              layout(scene = list(xaxis = list(title = continuous_vars),
                                  yaxis = list(title = discrete_vars),
                                  zaxis = list(title = 'Hustota')))
    
    # 2D modelovanie
    grouped_stats <- data %>%
      group_by(.data[[discrete_vars]]) %>%
      summarise(mean_x = mean(.data[[continuous_vars]], na.rm = TRUE),
                sd_x = sd(.data[[continuous_vars]], na.rm = TRUE),
                .groups = "drop")
    
    x_vals <- seq(min(data[[continuous_vars]], na.rm = TRUE), max(data[[continuous_vars]], na.rm = TRUE), length.out = 100)
    
    density_data <- grouped_stats %>%
      expand_grid(x = x_vals) %>%
      mutate(y = dnorm(x, mean = mean_x, sd = sd_x))
    
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      theme_minimal() +
      theme(legend.position = "right") +
      scale_color_manual(values = color_palette)
    
    x_density <- ggplot(density_data, aes(x = x, y = y, color = as.factor(.data[[discrete_vars]]), group = .data[[discrete_vars]])) +
      geom_line(size = 1) +
      scale_color_manual(values = color_palette) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = ""), color = discrete_vars) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")
    
    y_bar <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_manual(values = color_palette) +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")
    
    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  if (model_type == "kernel") {
    # Konverzia diskretnej premennej na faktor a zoradenie kategorii
    data[[discrete_vars]] <- factor(data[[discrete_vars]])
    categories <- levels(data[[discrete_vars]])

    # Vytvorenie konzistentnej farebnej mapy pre kategorie
    category_colors <- setNames(RColorBrewer::brewer.pal(length(categories), "Set1"), categories)

    calculate_density_3D <- function(data, category) {
      sub_data <- filter(data, .data[[discrete_vars]] == category)
      if (nrow(sub_data) > 1) {
        # Optimalizovany KDE odhad
        bw <- bw.nrd0(sub_data[[continuous_vars]])
        kde_x <- density(sub_data[[continuous_vars]], bw = bw)
        kde_x_fun <- approxfun(kde_x$x, kde_x$y, rule = 2)
    
        x <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
        x_density <- kde_x_fun(x)
    
        return(data.frame(Weight = x, Density = x_density, Category = category))
      } else {
        return(data.frame(Weight = numeric(0), Density = numeric(0), Category = character(0)))
      }
    }

    # Spojenie hustot pre vsetky kategorie
    density_data <- bind_rows(lapply(categories, function(cat) calculate_density_3D(data, cat)))

    fig_3d <- plot_ly(density_data, x = ~Weight, y = ~Category, z = ~Density, 
                       type = 'scatter3d', mode = 'lines', 
                       color = ~Category, colors = category_colors, line = list(width = 4)) %>%
              layout(scene = list(xaxis = list(title = continuous_vars),
                                  yaxis = list(title = discrete_vars),
                                  zaxis = list(title = 'Hustota')))

    data[[discrete_vars]] <- factor(data[[discrete_vars]], levels = categories)

    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      scale_color_manual(values = category_colors) +
      theme_minimal() +
      theme(legend.position = "right")

    x_density <- ggplot(data, aes_string(x = continuous_vars, fill = discrete_vars, color = discrete_vars)) +
      geom_density(alpha = 0.5) +
      scale_fill_manual(values = category_colors) +
      scale_color_manual(values = category_colors) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")

    y_bar <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_manual(values = category_colors) +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")

    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))

    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  if(model_type == "empiric") {
    data[[discrete_vars]] <- factor(data[[discrete_vars]])
    categories <- levels(data[[discrete_vars]])
    
    # Definovanie farebnej škály pre konzistentnosť
    color_palette <- RColorBrewer::brewer.pal(length(categories), "Set1")
    names(color_palette) <- categories
    
    # Výpočet empirickej hustoty pre každú kategóriu
    calculate_empirical_density_3D <- function(data, category) {
      sub_data <- filter(data, .data[[discrete_vars]] == category)
      if (nrow(sub_data) > 1) {
        density_est <- density(sub_data[[continuous_vars]], kernel = "gaussian")
        return(data.frame(Weight = density_est$x, Density = density_est$y, Age_Category = factor(category, levels = categories)))
      } else {
        return(data.frame(Weight = numeric(0), Density = numeric(0), Age_Category = factor(character(0), levels = categories)))
      }
    }
    
    density_data <- bind_rows(lapply(categories, function(cat) calculate_empirical_density_3D(data, cat)))
    
    fig_3d <- plot_ly(density_data, x = ~Weight, y = ~Age_Category, z = ~Density, 
                       type = 'scatter3d', mode = 'lines', 
                       color = ~Age_Category, colors = color_palette, line = list(width = 4)) %>%
              layout(scene = list(xaxis = list(title = continuous_vars),
                                  yaxis = list(title = discrete_vars),
                                  zaxis = list(title = 'Hustota')))
    
    # Výpočet empirickej hustoty pre každú kategóriu spojitej premennej
    density_data_2d <- bind_rows(lapply(categories, function(cat) {
      sub_data <- filter(data, .data[[discrete_vars]] == cat)
      if (nrow(sub_data) > 1) {
        density_est <- density(sub_data[[continuous_vars]], kernel = "gaussian")
        return(data.frame(x = density_est$x, y = density_est$y, Category = factor(cat, levels = categories)))
      } else {
        return(data.frame(x = numeric(0), y = numeric(0), Category = factor(character(0), levels = categories)))
      }
    }))
    
    x_density <- ggplot(density_data_2d, aes(x = x, y = y, color = Category, group = Category)) +
      geom_line(size = 1) +
      scale_color_manual(values = color_palette) +
      labs(x = NULL, y = paste("Empirická hustota (", continuous_vars, ")", sep = ""), color = discrete_vars) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")
    
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      theme_minimal() +
      theme(legend.position = "right") +
      scale_color_manual(values = color_palette)
    
    y_bar <- ggplot(data, aes(x = .data[[discrete_vars]], fill = .data[[discrete_vars]])) +
      geom_bar(alpha = 0.7) +
      scale_fill_manual(values = color_palette) +
      coord_flip() +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal()
    
    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
    
  }
  
}

```

```{r,warning=FALSE}
selected_variables <- c("cyl", "mpg")
result <- model_mixture_joint_distribution(mtcars, selected_variables, "empiric")
print(result)
```


```{r, warning=FALSE}
mixture_joint_distribution_surface_plot <- function(data, selected_variables, model_type) {
  # Identifikacia typov premennych
  variable_types <- identify_variables(data)
  discrete_vars <- intersect(variable_types$Diskretne, selected_variables)
  continuous_vars <- intersect(variable_types$Spojite, selected_variables)
  
  if(length(selected_variables) != 2 || length(discrete_vars) == 0 || length(continuous_vars) == 0) {
    stop("Zoznam premennych musi obsahovat prave 1 spojitu a 1 diskretnu premennu!")
  }
  
  # Modelovanie 3D hustoty ako hustoty normalneho rozdelenia (dnorm, surface plot)
  if (model_type == "normal") {
    # 3D modelovanie
    mean_x <- mean(data[[continuous_vars]])
    sd_x <- sd(data[[continuous_vars]])

    categories <- sort(unique(as.numeric(as.factor(data[[discrete_vars]]))))
    weights <- table(data[[discrete_vars]]) / nrow(data)

    cor_val <- cor(data[[continuous_vars]], as.numeric(as.factor(data[[discrete_vars]])), method = "pearson")
    copula_model <- normalCopula(param = cor_val, dim = 2, dispstr = "un")

    copula_density <- function(x, y) {
      u1 <- pnorm(x, mean = mean_x, sd = sd_x)
      u2 <- sum(sapply(seq_along(categories), function(i) {
        pnorm(y, mean = categories[i], sd = 0.1) * weights[i]
      }))
      copula_density <- dCopula(c(u1, u2), copula = copula_model)
      x_density <- dnorm(x, mean = mean_x, sd = sd_x)
      y_density <- sum(sapply(seq_along(categories), function(i) {
        dnorm(y, mean = categories[i], sd = 0.1) * weights[i]
      }))
      copula_density * x_density * y_density
    }

    x_vals <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
    y_vals <- seq(min(categories), max(categories), length.out = 100)
    grid <- expand.grid(x = x_vals, y = y_vals)
    z_vals <- apply(as.matrix(grid), 1, function(point) {
      copula_density(point[1], point[2])
    })

    density_vals_matrix <- matrix(z_vals, nrow = 100, ncol = 100)
    density_vals_matrix <- t(density_vals_matrix / max(density_vals_matrix))

    fig_3d <- plot_ly(
      x = ~x_vals, y = ~y_vals, z = ~density_vals_matrix,
      type = "surface",
      colors = colorRamp(c("blue", "cyan", "yellow", "red"))
    ) %>% layout(
      title = paste("Združená hustota", continuous_vars, "a", discrete_vars, "(kopula)"),
      scene = list(
        xaxis = list(title = continuous_vars),
        yaxis = list(title = discrete_vars),
        zaxis = list(title = "Hustota")
      )
    )
    
    # 2D modelovanie
    # Vypocet priemeru a smerodajnej odchylky pre kazdu kategoriu diskretnej premennej
    grouped_stats <- data %>%
      group_by(.data[[discrete_vars]]) %>%
      summarise(mean_x = mean(.data[[continuous_vars]], na.rm = TRUE),
                sd_x = sd(.data[[continuous_vars]], na.rm = TRUE),
                .groups = "drop")
    
    # Vygenerovanie hodnot pre vykreslenie normalnych hustot pre kazdu kategoriu
    x_vals <- seq(min(data[[continuous_vars]], na.rm = TRUE), max(data[[continuous_vars]], na.rm = TRUE), length.out = 100)
    
    # Vytvorenie datasetu na vizualizaciu hustotnych kriviek pre kazdu kategoriu
    density_data <- grouped_stats %>%
      expand_grid(x = x_vals) %>%
      mutate(y = dnorm(x, mean = mean_x, sd = sd_x))
    
    # Konverzia diskretnej premennej na faktor
    data[[discrete_vars]] <- as.factor(data[[discrete_vars]])
    
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      theme_minimal() +
      theme(legend.position = "right") +
      scale_color_brewer(palette = "Set1")
    
    x_density <- ggplot(density_data, aes(x = x, y = y, color = as.factor(.data[[discrete_vars]]), group = .data[[discrete_vars]])) +
      geom_line(size = 1) +
      scale_color_brewer(palette = "Set1") +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = ""), color = discrete_vars) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")
    
    y_bar <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_brewer(palette = "Set1") +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")
    
    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  # Modelovanie hustoty pomocou jadroveho vyhladzovania (surface plot)
  if (model_type == "kernel") {
    categories <- sort(unique(as.numeric(as.factor(data[[discrete_vars]]))))
    # Odhad marginalnej hustoty spojitej premennej pomocou KDE
    kde_x <- density(data[[continuous_vars]])
    kde_x_fun <- approxfun(kde_x$x, kde_x$y, rule = 2)
    ecdf_x_fun <- ecdf(data[[continuous_vars]])
    
    # Odhad marginalnej hustoty diskretnej premennej pomocou KDE
    kde_y <- kde(as.numeric(as.factor(data[[discrete_vars]])))  
    kde_y_fun <- approxfun(kde_y$eval.points, kde_y$estimate, rule = 2)
    pkde_y_fun <- function(y) ks::pkde(y, kde_y)  # KDE zalozene na CDF pre diskretnu premennu
    
    # Odhad Pearsonovej korelacie medzi spojitou a diskretnou premennou
    cor_val <- cor(data[[continuous_vars]], as.numeric(as.factor(data[[discrete_vars]])), method = "pearson")
    
    # Definicia normalnej kopuly na zaklade korelacie
    copula_model <- normalCopula(param = cor_val, dim = 2, dispstr = "un")

  
    # Funkcia zdruzenej hustoty s KDE a kopulou
    copula_density <- function(x, y) {
      u1 <- ecdf_x_fun(x)  # Transformacia KDE na [0,1]
      u2 <- pkde_y_fun(y)
  
      copula_density <- dCopula(c(u1, u2), copula = copula_model)
      x_density <- kde_x_fun(x)  
      y_density <- kde_y_fun(y)
      
      copula_density * x_density * y_density
    }

    # Generovanie bodov a vypocet hustoty
    x_vals <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
    y_vals <- seq(min(categories), max(categories), length.out = 100)
    grid <- expand.grid(x = x_vals, y = y_vals)
    z_vals <- apply(as.matrix(grid), 1, function(point) {
      copula_density(point[1], point[2])
    })
    
    # Normalizacia a vizualizacia
    density_vals_matrix <- matrix(z_vals, nrow = 100, ncol = 100)
    density_vals_matrix <- t(density_vals_matrix / max(density_vals_matrix))
  
    fig_3d <- plot_ly(
      x = ~x_vals, y = ~y_vals, z = ~density_vals_matrix,
      type = "surface",
      colors = colorRamp(c("blue", "cyan", "yellow", "red"))
    ) %>% layout(
      title = paste("Združená hustota", continuous_vars, "a", discrete_vars, "(KDE + kopula)"),
      scene = list(
        xaxis = list(title = continuous_vars),
        yaxis = list(title = discrete_vars),
        zaxis = list(title = "Hustota")
      )
    )
    
    data[[discrete_vars]] <- as.factor(data[[discrete_vars]])

    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      theme_minimal() +
      theme(legend.position = "right") +
      scale_color_brewer(palette = "Set1")
    
    x_density <- ggplot(data, aes_string(x = continuous_vars, fill = discrete_vars, color = discrete_vars)) +
      geom_density(alpha = 0.5) +
      scale_fill_brewer(palette = "Set1") +
      scale_color_brewer(palette = "Set1") +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")
    
    y_bar <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_brewer(palette = "Set1") +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")
    
    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
}
```

```{r,warning=FALSE}
selected_variables <- c("cyl", "mpg")
result <- mixture_joint_distribution_surface_plot(mtcars, selected_variables, "kernel")
print(result)
```

# Modelovanie zdruzeneho rozdelenia pravdepodobnosti 2 spojitych premennych

```{r, warning=FALSE}
model_continuous_joint_distribution <- function(data, selected_variables) {
  # Identifikácia typov premenných
  variable_types <- identify_variables(data)
  discrete_vars <- intersect(variable_types$Diskretne, selected_variables)
  continuous_vars <- intersect(variable_types$Spojite, selected_variables)
  
  if (length(selected_variables) != 2 || length(discrete_vars) > 0) {
    stop("Na vstup musia ist 2 spojite nahodne premenne!")
  }
  
  # Modelovanie pomocou kopule
  # mean_x <- mean(data[[continuous_vars[1]]])
  # sd_x <- sd(data[[continuous_vars[1]]])
  # mean_y <- mean(data[[continuous_vars[2]]])
  # sd_y <- sd(data[[continuous_vars[2]]])
  # 
  # cor_val <- cor(data[[continuous_vars[1]]], data[[continuous_vars[2]]], method = "pearson")
  # copula_model <- normalCopula(param = cor_val, dim = 2, dispstr = "un")
  # 
  # copula_density <- function(x, y) {
  #   u1 <- pnorm(x, mean = mean_x, sd = sd_x)
  #   u2 <- pnorm(y, mean = mean_y, sd = sd_y)
  #   
  #   copula_density <- dCopula(c(u1, u2), copula = copula_model)
  #   x_density <- dnorm(x, mean = mean_x, sd = sd_x)
  #   y_density <- dnorm(y, mean = mean_y, sd = sd_y)
  #   
  #   copula_density * x_density * y_density
  # }
  #   
  # x_vals <- seq(min(data[[continuous_vars[1]]]), max(data[[continuous_vars[1]]]), length.out = 100)
  # y_vals <- seq(min(data[[continuous_vars[2]]]), max(data[[continuous_vars[2]]]), length.out = 100)
  # grid <- expand.grid(x = x_vals, y = y_vals)
  # z_vals <- apply(as.matrix(grid), 1, function(point) {
  #   copula_density(point[1], point[2])
  # })
  # density_vals_matrix <- matrix(z_vals, nrow = 100, ncol = 100)
  # density_vals_matrix <- density_vals_matrix / max(density_vals_matrix)
  # 
  # fig_3d <- plot_ly(
  #   x = ~x_vals, y = ~y_vals, z = ~density_vals_matrix,
  #   type = "surface",
  #   colors = colorRamp(c("blue", "cyan", "yellow", "red"))
  # ) %>% layout(
  #   title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], "(kopula)"),
  #   scene = list(
  #     xaxis = list(title = continuous_vars[1]),
  #     yaxis = list(title = continuous_vars[2]),
  #     zaxis = list(title = "Hustota")
  #   )
  # )
  
  # Modelovanie pomocou jadrového vyhladzovania
  kde_result <- kde2d(
    x = data[[continuous_vars[1]]], 
    y = data[[continuous_vars[2]]], 
    n = 100
  )
  
  fig_3d <- plot_ly(
    x = ~kde_result$x, y = ~kde_result$y, z = ~kde_result$z,
    type = "surface",
    colors = colorRamp(c("blue", "cyan", "yellow", "red"))
  ) %>% layout(
    title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], "(jadrové   vyhladzovanie)"),
    scene = list(
      xaxis = list(title = continuous_vars[1]),
      yaxis = list(title = continuous_vars[2]),
      zaxis = list(title = "Hustota")
    )
  )
    
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
      geom_point(size = 3, alpha = 0.7) +  
      labs(x = continuous_vars[1], y = continuous_vars[2]) +
      scale_color_gradient(low = "blue", high = "red") +
      theme_minimal()

    density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
      geom_density(fill = "blue", alpha = 0.5) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

    density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
      geom_density(fill = "red", alpha = 0.5) +
      coord_flip() +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
    
    final_plot_2d <- (density_x + plot_spacer()) /
                    (scatter_plot + density_y) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
}
```

```{r,warning=FALSE}
continuous_variables <- c("disp", "hp")
result <- model_continuous_joint_distribution(mtcars, continuous_variables)
print(result)
```


# Modelovanie zdruzeneho rozdelenia pravdepodobnosti viac ako 2 premennych

```{r,warning=FALSE}
model_multi_joint_distribution <- function(data, selected_variables) {
  variables_count <- length(selected_variables)
  if (variables_count <= 2) {
    stop("Tato funkcia sluzi na modelovanie 3 a viac premennych!")
  }
  
  # Identifikácia typov premenných
  variable_types <- identify_variables(data)
  discrete_vars <- intersect(variable_types$Diskretne, selected_variables)
  continuous_vars <- intersect(variable_types$Spojite, selected_variables)
  
  # Vytvorenie tabulky s frekvenciami pre diskretne premenne
  tab <- as.data.frame(table(data[, discrete_vars]))
  
  # Pre každú spojitú premennú vypočítame priemerné hodnoty pre kombinácie diskrétnych premenných
  for (cont_var in continuous_vars) {
    mean_values <- data %>%
      group_by(across(all_of(discrete_vars))) %>%
      summarise(Mean_Value = mean(.data[[cont_var]], na.rm = TRUE), .groups = "drop")
    
    # mean_values neobsahuje žiadne riadky => preskočíme túto premennú
    if (nrow(mean_values) == 0) {
      warning(paste("Žiadne dáta na výpočet priemeru pre premennú:", cont_var))
      next
    }
    
    # Overenie, ktoré diskrétne premenné existujú v tab a mean_values
    common_vars <- intersect(names(tab), discrete_vars)
    common_vars_mv <- intersect(names(mean_values), discrete_vars)
    
    # Existujú spoločné premenné => prevedenie na character
    if (length(common_vars) > 0) {
      tab <- tab %>%
        mutate(across(all_of(common_vars), as.character))
    }
    if (length(common_vars_mv) > 0) {
      mean_values <- mean_values %>%
        mutate(across(all_of(common_vars_mv), as.character))
    }
    
    # Spojenie priemerných hodnôt so základnou tabuľkou
    tab <- full_join(tab, mean_values, by = common_vars)
    
    # Premenovanie stĺpca Mean_Value na názov spojitej premennej
    colnames(tab)[which(colnames(tab) == "Mean_Value")] <- cont_var
  }
  
  # Náhrada NA vo Frequency nulami
  tab$Freq[is.na(tab$Freq)] <- 0
  
  # Výpočet pravdepodobnosti
  tab$Probability <- tab$Freq / sum(tab$Freq)
  
  # Odstránenie riadkov s nulovou frekvenciou
  tab <- tab[tab$Freq > 0, ]
  
  return(tab)
}
```

```{r,warning=FALSE}
multiple_variables <- c("mpg", "disp", "cyl")
result2 <- model_multi_joint_distribution(mtcars, multiple_variables)
print(result2)
```

# Modelovanie dvoch dikretnych nahodnych premennych

```{r,warning=FALSE}
model_discrete_joint_distribution <- function(data, selected_variables) {
  # Identifikácia typov premenných
  variable_types <- identify_variables(data)
  discrete_vars <- intersect(variable_types$Diskretne, selected_variables)
  continuous_vars <- intersect(variable_types$Spojite, selected_variables)
  
  if (length(selected_variables) != 2 || length(continuous_vars) > 0) {
    stop("Na vstup musia ist 2 diskretne nahodne premenne!")
  }
  
  tab <- as.data.frame(table(data[, discrete_vars]))
  tab$Probability <- tab$Freq / sum(tab$Freq)

  tab[[discrete_vars[1]]] <- as.numeric(as.character(tab[[discrete_vars[1]]]))
  tab[[discrete_vars[2]]] <- as.numeric(as.character(tab[[discrete_vars[2]]]))

  fig_3d <- plot_ly()
  for (i in 1:nrow(tab)) {
      fig_3d <- fig_3d %>% add_trace(
          x = rep(tab[[discrete_vars[1]]][i], 2),
          y = rep(tab[[discrete_vars[2]]][i], 2),
          z = c(0, tab$Probability[i]),
          type = "scatter3d",
          mode = "lines",
          line = list(color = "blue"),
          showlegend = FALSE
      )
  }

  fig_3d <- fig_3d %>% add_trace(
      x = tab[[discrete_vars[1]]],
      y = tab[[discrete_vars[2]]],
      z = tab$Probability,
      type = "scatter3d",
      mode = "markers",
      marker = list(size = 5, color = "red"),
      name = "Pravdepodobnosti"
  )

  fig_3d <- fig_3d %>% layout(
      scene = list(
          xaxis = list(title = paste0(discrete_vars[1], " (X)")),
          yaxis = list(title = paste0(discrete_vars[2], " (Y)")),
          zaxis = list(title = "P(X, Y)")
      )
  )

    marginal_x <- tab %>%
  group_by(!!sym(discrete_vars[1])) %>%
  summarise(Prob_X = sum(Probability))

  marginal_y <- tab %>%
    group_by(!!sym(discrete_vars[2])) %>%
    summarise(Prob_Y = sum(Probability))
  
  # 2D vizualizacia
  scatter_plot <- ggplot(tab, aes_string(x = discrete_vars[1], y = discrete_vars[2], fill =   "Probability")) +
    geom_tile(color = "white") +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(x = discrete_vars[1], y = discrete_vars[2], fill = "Pravdepodobnosť") +
    theme_minimal()
  
  marginal_x_plot <- ggplot(marginal_x, aes_string(x = discrete_vars[1], y = "Prob_X")) +
    geom_bar(stat = "identity", fill = "blue", alpha = 0.6) +
    labs(x = NULL, y = "P(X)") +
    theme_minimal()
  
  marginal_y_plot <- ggplot(marginal_y, aes_string(x = discrete_vars[2], y = "Prob_Y")) +
    geom_bar(stat = "identity", fill = "red", alpha = 0.6) +
    coord_flip() +
    labs(x = NULL, y = "P(Y)") +
    theme_minimal()
  
  final_plot_2d <- (marginal_x_plot + plot_spacer()) /
                   (scatter_plot + marginal_y_plot) +
                   plot_layout(widths = c(4, 1), heights = c(1, 4))

  return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
}
```

```{r, warning=FALSE}
selected_discrete_variables <- c("gear", "carb")
result <- model_joint_distribution(mtcars, selected_discrete_variables)
print(result)
```



