---
title: "Modelling joint probability distribution of
a mixture of continuous and categorical
random variables"
author: "Adam Harmaniak"
date: "2025-02-21"
output: html_document
---

# Pouzite kniznice

```{r,warning=FALSE}
suppressMessages(suppressWarnings({
  library(ggplot2)
  library(plotly)
  library(copula)
  library(patchwork)
  library(dplyr)
  library(tibble)
  library(MASS)
  library(randomForest)
  library(mgcv)
  library(ks)
  library(tidyr)
  library(evd)
  library(mvtnorm)
  library(quantreg)
  library(splines)
}))

data <- mtcars

```

# Identifikacia a vypis premennych

```{r, warning=FALSE}
identify_variables <- function(data) {
  variable_types <- sapply(data, function(col) {
    if (is.factor(col) || is.character(col) || (is.numeric(col) && length(unique(col)) < 10)) {
      return("Diskretna")
    } else {
      return("Spojita")
    }
  })
  
  discrete_vars <- names(variable_types[variable_types == "Diskretna"])
  continuous_vars <- names(variable_types[variable_types == "Spojita"])
  
  return(list(Diskretne = discrete_vars, Spojite = continuous_vars))
}
```

```{r, warning=FALSE}
printVariables <- function(data) {
  num_variables <- length(colnames(data))
  variables <- identify_variables(data)

  all_variables <- c(variables$Diskretne, variables$Spojite)

  variable_types <- c(rep("Diskrétna", length(variables$Diskretne)),
                      rep("Spojitá", length(variables$Spojite)))

  counts <- sapply(all_variables, function(var) sum(!is.na(data[[var]])))

  table_result <- tibble(
    Index = seq_len(num_variables),
    Variable_Name = all_variables,
    Variable_Type = variable_types,
    Pocet_pozorovani = counts
  )

  print(table_result)
}
```

# Funkcia na modelovanie zdruzenej hustoty 1 spojitej a 1 diskretnej nahodnej premennej

```{r, warning=FALSE}
mixture_joint_distribution <- function(data, discrete_vars, continuous_vars, model_type, bw = NULL) {
  
  # Modelovanie hustoty pouzitim jadroveho vyhladzovania
  if (model_type == "kernel") {
    # Konverzia diskretnej premennej na faktor a zoradenie kategorii
    data[[discrete_vars]] <- factor(data[[discrete_vars]])
    categories <- levels(data[[discrete_vars]])

    # Vytvorenie farebnej mapy pre kategorie
    category_colors <- setNames(RColorBrewer::brewer.pal(length(categories), "Set1"), categories)

    calculate_density_3D <- function(data, category) {
      sub_data <- filter(data, .data[[discrete_vars]] == category)
      if (nrow(sub_data) > 1) {
        if (is.null(bw)){
          bw <- bw.nrd0(sub_data[[continuous_vars]])
        }
        kde_x <- density(sub_data[[continuous_vars]], bw = bw)
        kde_x_fun <- approxfun(kde_x$x, kde_x$y, rule = 2)
    
        x <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
        x_density <- kde_x_fun(x)
    
        return(data.frame(Weight = x, Density = x_density, Category = category))
      } else {
        return(data.frame(Weight = numeric(0), Density = numeric(0), Category = character(0)))
      }
    }

    # Spojenie hustot pre vsetky kategorie
    density_data <- bind_rows(lapply(categories, function(cat) calculate_density_3D(data, cat)))

    # 3D Vizualizacia
    fig_3d <- plot_ly(density_data, x = ~Weight, y = ~Category, z = ~Density, 
                       type = 'scatter3d', mode = 'lines', 
                       color = ~Category, colors = category_colors, line = list(width = 4)) %>%
              layout(scene = list(xaxis = list(title = continuous_vars),
                                  yaxis = list(title = discrete_vars),
                                  zaxis = list(title = 'Hustota')))
    
    # 2D Vizualizacia
    data[[discrete_vars]] <- factor(data[[discrete_vars]], levels = categories)

    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      scale_color_manual(values = category_colors) +
      theme_minimal() +
      theme(legend.position = "right")

    x_density <- ggplot(data, aes_string(x = continuous_vars, fill = discrete_vars, color = discrete_vars)) +
      geom_density(alpha = 0.5) +
      scale_fill_manual(values = category_colors) +
      scale_color_manual(values = category_colors) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")

    y_bar <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_manual(values = category_colors) +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")

    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))

    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  # Modelovanie hustoty ako hustoty normalneho rozdelenia (dnorm)
  if (model_type == "normal") {
    # Konverzia diskretnej premennej na faktor a zoradenie kategorii
    data[[discrete_vars]] <- factor(data[[discrete_vars]])
    categories <- levels(data[[discrete_vars]])
    
    # Vytvorenie farebnej mapy pre kategorie
    category_colors <- RColorBrewer::brewer.pal(length(categories), "Set1")
    names(category_colors) <- categories
    
    # Vypocet hustoty pre kazdu kategoriu
    calculate_density_3D <- function(data, category) {
      sub_data <- filter(data, .data[[discrete_vars]] == category)
      if (nrow(sub_data) > 1) {
        mu <- mean(sub_data[[continuous_vars]])
        sigma <- sd(sub_data[[continuous_vars]])
        x <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
        density <- dnorm(x, mean = mu, sd = sigma)
        return(data.frame(Continuous_Var = x, Density = density, Discrete_Var = factor(category, levels = categories)))
      } else {
        return(data.frame(Continuous_Var = numeric(0), Density = numeric(0), Discrete_Var = factor(character(0), levels = categories)))
      }
    }

    # Spojenie hustot pre vsetky kategorie
    density_data <- bind_rows(lapply(categories, function(cat) calculate_density_3D(data, cat)))

    # 3D Vizualizacia
    fig_3d <- plot_ly(density_data, x = ~Continuous_Var, y = ~Discrete_Var, z = ~Density, 
                       type = 'scatter3d', mode = 'lines', 
                       color = ~Discrete_Var, colors = category_colors, line = list(width = 4)) %>%
              layout(scene = list(xaxis = list(title = continuous_vars),
                                  yaxis = list(title = discrete_vars),
                                  zaxis = list(title = 'Hustota')))
    
    # 2D Vizualizacia
    grouped_stats <- data %>%
      group_by(.data[[discrete_vars]]) %>%
      summarise(mean_x = mean(.data[[continuous_vars]], na.rm = TRUE),
                sd_x = sd(.data[[continuous_vars]], na.rm = TRUE),
                .groups = "drop")
    
    x_vals <- seq(min(data[[continuous_vars]], na.rm = TRUE), max(data[[continuous_vars]], na.rm = TRUE), length.out = 100)
    
    density_data <- grouped_stats %>%
      expand_grid(x = x_vals) %>%
      mutate(y = dnorm(x, mean = mean_x, sd = sd_x))
    
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      theme_minimal() +
      theme(legend.position = "right") +
      scale_color_manual(values = category_colors)
    
    x_density <- ggplot(density_data, aes(x = x, y = y, color = as.factor(.data[[discrete_vars]]), group = .data[[discrete_vars]])) +
      geom_line(size = 1) +
      scale_color_manual(values = category_colors) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = ""), color = discrete_vars) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")
    
    y_bar <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_manual(values = category_colors) +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")
    
    final_plot_2d <- (x_density + plot_spacer()) /
                    (scatter_plot + y_bar) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  # Modelovanie hustoty ako hustoty Studentovho t-rozdelenia (dt)
  if (model_type == "t") {
    # Konverzia diskretnej premennej na faktor a zoradenie kategorii
    data[[discrete_vars]] <- factor(data[[discrete_vars]])
    categories <- levels(data[[discrete_vars]])
    
    # Vytvorenie farebnej mapy pre kategorie
    category_colors <- RColorBrewer::brewer.pal(length(categories), "Set1")
    names(category_colors) <- categories
    
    # Vypocet hustoty pre kazdu kategoriu
    calculate_density_3D_t <- function(data, category) {
      sub_data <- filter(data, .data[[discrete_vars]] == category)
      if (nrow(sub_data) > 2) {
        mu <- mean(sub_data[[continuous_vars]])
        sigma <- sd(sub_data[[continuous_vars]])
        df_t <- nrow(sub_data) - 1  # stupne volnosti pre t-rozdelenie
        x <- seq(min(data[[continuous_vars]]), max(data[[continuous_vars]]), length.out = 100)
        density <- dt((x - mu) / sigma, df = df_t) / sigma
        return(data.frame(Continuous_Var = x, Density = density, Discrete_Var = factor(category, levels = categories)))
      } else {
        return(data.frame(Continuous_Var = numeric(0), Density = numeric(0), Discrete_Var = factor(character(0), levels = categories)))
      }
    }

    # Spojenie hustot pre vsetky kategorie
    density_data_t <- bind_rows(lapply(categories, function(cat) calculate_density_3D_t(data, cat)))

    # 3D Vizualizacia
    fig_3d_t <- plot_ly(density_data_t, x = ~Continuous_Var, y = ~Discrete_Var, z = ~Density, 
                         type = 'scatter3d', mode = 'lines', 
                         color = ~Discrete_Var, colors = category_colors, line = list(width = 4)) %>%
                layout(scene = list(xaxis = list(title = continuous_vars),
                                    yaxis = list(title = discrete_vars),
                                    zaxis = list(title = 'Hustota')))
    
    # 2D Vizualizacia
    grouped_stats_t <- data %>%
      group_by(.data[[discrete_vars]]) %>%
      summarise(mean_x = mean(.data[[continuous_vars]], na.rm = TRUE),
                sd_x = sd(.data[[continuous_vars]], na.rm = TRUE),
                df_x = n() - 1,
                .groups = "drop")
    
    x_vals <- seq(min(data[[continuous_vars]], na.rm = TRUE), max(data[[continuous_vars]], na.rm = TRUE), length.out = 100)
    
    density_data_t <- grouped_stats_t %>%
      expand_grid(x = x_vals) %>%
      mutate(y = dt((x - mean_x) / sd_x, df = df_x) / sd_x)
    
    scatter_plot_t <- ggplot(data, aes_string(x = continuous_vars, y = discrete_vars, color = discrete_vars)) +
      geom_point(size = 3, alpha = 0.7) +
      labs(x = continuous_vars, y = discrete_vars) +
      theme_minimal() +
      theme(legend.position = "right") +
      scale_color_manual(values = category_colors)
    
    x_density_t <- ggplot(density_data_t, aes(x = x, y = y, color = as.factor(.data[[discrete_vars]]), group = .data[[discrete_vars]])) +
      geom_line(size = 1) +
      scale_color_manual(values = category_colors) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars, ")", sep = ""), color = discrete_vars) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = "right")
    
    y_bar_t <- ggplot(data, aes_string(x = discrete_vars, fill = discrete_vars)) +
      geom_bar(alpha = 0.7) +
      coord_flip() +
      scale_fill_manual(values = category_colors) +
      labs(x = NULL, y = paste("P(", discrete_vars, ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.position = "right")
    
    final_plot_2d_t <- (x_density_t + plot_spacer()) /
                      (scatter_plot_t + y_bar_t) +
                      plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d_t, final_plot_2d = final_plot_2d_t))
    
  }
  
}
```

# Modelovanie zdruzeneho rozdelenia pravdepodobnosti 2 spojitych premennych

```{r, warning=FALSE}
continuous_joint_distribution <- function(data, continuous_vars, model_type) {
  
  # Modelovanie hustoty pomocou jadroveho vyhladzovania
  if (model_type == "kernel"){
    kde_result <- kde2d(
    x = data[[continuous_vars[1]]], 
    y = data[[continuous_vars[2]]], 
    n = 100
  )
  
  fig_3d <- plot_ly(
    x = ~kde_result$x, y = ~kde_result$y, z = ~kde_result$z,
    type = "surface",
    colors = colorRamp(c("blue", "cyan", "yellow", "red"))
  ) %>% layout(
    title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], "(jadrové   vyhladzovanie)"),
    scene = list(
      xaxis = list(title = continuous_vars[1]),
      yaxis = list(title = continuous_vars[2]),
      zaxis = list(title = "Hustota")
    )
  )
    
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
      geom_point(size = 3, alpha = 0.7) +  
      labs(x = continuous_vars[1], y = continuous_vars[2]) +
      scale_color_gradient(low = "blue", high = "red") +
      theme_minimal()

    density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
      geom_density(fill = "blue", alpha = 0.5) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

    density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
      geom_density(fill = "red", alpha = 0.5) +
      coord_flip() +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
    
    final_plot_2d <- (density_x + plot_spacer()) /
                    (scatter_plot + density_y) +
                    plot_layout(widths = c(4, 1), heights = c(1, 4))
    
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d)) 
  }
  
  # Modelovanie zdruzenej hustoty ako hustoty normalneho rozdelenia
  if (model_type == "normal") {
    # Vypocet zakladnych parametrov (momentov)
    mean_x <- mean(data[[continuous_vars[1]]], na.rm = TRUE)
    sd_x <- sd(data[[continuous_vars[1]]], na.rm = TRUE)
    mean_y <- mean(data[[continuous_vars[2]]], na.rm = TRUE)
    sd_y <- sd(data[[continuous_vars[2]]], na.rm = TRUE)
  
    # Korelacia medzi premennymi
    cor_val <- cor(data[[continuous_vars[1]]], data[[continuous_vars[2]]], method = "pearson", use = "complete.obs")
  
    # Funkcia na vypocet bivariatnej normalnej hustoty (kvazi dnorm() ale v 2D)
    bivariate_normal_density <- function(x, y) {
      rho <- cor_val
      z_x <- (x - mean_x) / sd_x
      z_y <- (y - mean_y) / sd_y
      
      exponent <- -1 / (2 * (1 - rho^2)) * (z_x^2 + z_y^2 - 2 * rho * z_x * z_y)
      density <- (1 / (2 * pi * sd_x * sd_y * sqrt(1 - rho^2))) * exp(exponent)
      
      return(density)
    }
  
    # Siet pre vypocet hustoty
    x_vals <- seq(min(data[[continuous_vars[1]]], na.rm = TRUE), max(data[[continuous_vars[1]]], na.rm = TRUE), length.out = 100)
    y_vals <- seq(min(data[[continuous_vars[2]]], na.rm = TRUE), max(data[[continuous_vars[2]]], na.rm = TRUE), length.out = 100)
  
    grid <- expand.grid(x = x_vals, y = y_vals)
  
    # Vypocet hustoty na sieti
    grid$z <- mapply(bivariate_normal_density, grid$x, grid$y)
    z_matrix <- matrix(grid$z, nrow = 100, byrow = FALSE)
  
    # 3D Vizualizacia
    fig_3d <- plot_ly(
      x = ~x_vals, y = ~y_vals, z = ~z_matrix,
      type = "surface",
      colors = colorRamp(c("blue", "cyan", "yellow", "red"))
    ) %>% layout(
      title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], "(bivariátne normálne rozdelenie)"),
      scene = list(
        xaxis = list(title = continuous_vars[1]),
        yaxis = list(title = continuous_vars[2]),
        zaxis = list(title = "Hustota")
      )
    )
  
    # 2D Vizualizacia
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
      geom_point(size = 3, alpha = 0.7) +  
      labs(x = continuous_vars[1], y = continuous_vars[2]) +
      scale_color_gradient(low = "blue", high = "red") +
      theme_minimal()
  
    density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
      stat_function(fun = dnorm, args = list(mean = mean_x, sd = sd_x), fill = "blue", geom = "area", alpha = 0.5) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
    density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
      stat_function(fun = dnorm, args = list(mean = mean_y, sd = sd_y), fill = "red", geom = "area", alpha = 0.5) +
      coord_flip() +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
  
    final_plot_2d <- (density_x + plot_spacer()) /
                     (scatter_plot + density_y) +
                     plot_layout(widths = c(4, 1), heights = c(1, 4))
  
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  # Modelovanie zdruzenej hustoty ako hustoty Studentovho t-rozdelenia
  if (model_type == "t") {
    # Vypocet zakladnych parametrov (momentov)
    mean_x <- mean(data[[continuous_vars[1]]], na.rm = TRUE)
    sd_x <- sd(data[[continuous_vars[1]]], na.rm = TRUE)
    mean_y <- mean(data[[continuous_vars[2]]], na.rm = TRUE)
    sd_y <- sd(data[[continuous_vars[2]]], na.rm = TRUE)
  
    # Korelacia medzi premennymi (Pearson)
    cor_val <- cor(data[[continuous_vars[1]]], data[[continuous_vars[2]]], method = "pearson", use = "complete.obs")
  
    # Kovariancna matica (smerodajne odchylky/rozptyly a korelacia)
    Sigma <- matrix(c(sd_x^2, cor_val * sd_x * sd_y,
                      cor_val * sd_x * sd_y, sd_y^2), nrow = 2)
  
    # Inverzna kovariancná matica
    Sigma_inv <- solve(Sigma)
  
    # Determinant kovariancnej matice
    det_Sigma <- det(Sigma)
  
    # Stupne volnosti
    df <- nrow(data) - 1
  
    # Bivariatna Studentova t-hustota
    bivariate_t_density <- function(x, y) {
      z <- c(x - mean_x, y - mean_y)
      quad_form <- t(z) %*% Sigma_inv %*% z
  
      coeff <- gamma((df + 2) / 2) / (gamma(df / 2) * (df * pi) * sqrt(det_Sigma))
      exponent <- (1 + quad_form / df) ^ (-(df + 2) / 2)
  
      return(as.numeric(coeff * exponent))
    }
  
    # Siet pre vypocet hustoty
    x_vals <- seq(min(data[[continuous_vars[1]]], na.rm = TRUE), max(data[[continuous_vars[1]]], na.rm = TRUE), length.out = 100)
    y_vals <- seq(min(data[[continuous_vars[2]]], na.rm = TRUE), max(data[[continuous_vars[2]]], na.rm = TRUE), length.out = 100)
  
    grid <- expand.grid(x = x_vals, y = y_vals)
  
    # Vypocet hustoty na sieti
    grid$z <- mapply(bivariate_t_density, grid$x, grid$y)
    z_matrix <- matrix(grid$z, nrow = 100, byrow = FALSE)
  
    # 3D Vizualizacia
    fig_3d <- plot_ly(
      x = ~x_vals, y = ~y_vals, z = ~z_matrix,
      type = "surface",
      colors = colorRamp(c("blue", "cyan", "yellow", "red"))
    ) %>% layout(
      title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], "(bivariátne t-rozdelenie)"),
      scene = list(
        xaxis = list(title = continuous_vars[1]),
        yaxis = list(title = continuous_vars[2]),
        zaxis = list(title = "Hustota")
      )
    )
  
    # 2D Vizualizacia
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
      geom_point(size = 3, alpha = 0.7) +  
      labs(x = continuous_vars[1], y = continuous_vars[2]) +
      scale_color_gradient(low = "blue", high = "red") +
      theme_minimal()
  
    density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
      stat_function(fun = function(x) dt((x - mean_x) / sd_x, df = df) / sd_x, fill = "blue", geom = "area", alpha = 0.5) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
    density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
      stat_function(fun = function(y) dt((y - mean_y) / sd_y, df = df) / sd_y, fill = "red", geom = "area", alpha = 0.5) +
      coord_flip() +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
  
    final_plot_2d <- (density_x + plot_spacer()) /
                     (scatter_plot + density_y) +
                     plot_layout(widths = c(4, 1), heights = c(1, 4))
  
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
}
```

```{r, warning=FALSE}
continuous_joint_distribution_copula <- function(data, continuous_vars, model_type, copula_type = NULL) {

  # Modelovanie hustoty pomocou jadroveho vyhladzovania a kopuly (rozklad na marginaly)
  if (model_type == "kernel") {
    kde_x <- density(data[[continuous_vars[1]]], n = 512)
  kde_y <- density(data[[continuous_vars[2]]], n = 512)

  # Funkcie pre hustoty a distribucne funkcie KDE
  kde_x_density <- approxfun(kde_x$x, kde_x$y, rule = 2)
  kde_x_cdf <- approxfun(kde_x$x, cumsum(kde_x$y) / sum(kde_x$y), rule = 2)

  kde_y_density <- approxfun(kde_y$x, kde_y$y, rule = 2)
  kde_y_cdf <- approxfun(kde_y$x, cumsum(kde_y$y) / sum(kde_y$y), rule = 2)

  # Transformacia dat na jednotkovy interval
  u1 <- kde_x_cdf(data[[continuous_vars[1]]])
  u2 <- kde_y_cdf(data[[continuous_vars[2]]])

  empirical_data <- pobs(cbind(u1, u2))  # zoradenie do [0, 1]

  if (copula_type == "empirical") {
    copula_model <- empCopula(empirical_data, smoothing = "beta")
  } else {
    stop("Zadaný 'copula_type' nie je podporovaný. Použi: 'empirical'.")
  }

  # Vytvorenie siete pre vypocet hustoty
  x_vals <- seq(min(data[[continuous_vars[1]]], na.rm = TRUE), max(data[[continuous_vars[1]]], na.rm = TRUE), length.out = 100)
  y_vals <- seq(min(data[[continuous_vars[2]]], na.rm = TRUE), max(data[[continuous_vars[2]]], na.rm = TRUE), length.out = 100)

  grid <- expand.grid(x = x_vals, y = y_vals)

  # Funkcia pre vypocet zdruzenej hustoty KDE + kopula
  copula_density_function <- function(x, y) {
    u1 <- kde_x_cdf(x)
    u2 <- kde_y_cdf(y)

    # Hustota kopuly v bode (u1, u2)
    copula_density <- dCopula(cbind(u1, u2), copula = copula_model)

    marginal_x <- kde_x_density(x)
    marginal_y <- kde_y_density(y)

    copula_density * marginal_x * marginal_y
  }

  # Vypocet hustoty na sieti
  grid$z <- mapply(copula_density_function, grid$x, grid$y)
  z_matrix <- matrix(grid$z, nrow = 100, byrow = FALSE)

  # 3D Vizualizacia
  fig_3d <- plot_ly(
    x = ~x_vals, y = ~y_vals, z = ~z_matrix,
    type = "surface",
    colors = colorRamp(c("blue", "cyan", "yellow", "red"))
  ) %>% layout(
    title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], paste0(" (KDE + ", copula_type, " kopula)")),
    scene = list(
      xaxis = list(title = continuous_vars[1]),
      yaxis = list(title = continuous_vars[2]),
      zaxis = list(title = "Hustota")
    )
  )

  # 2D Vizualizacia
  scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
    geom_point(size = 3, alpha = 0.7) +
    labs(x = continuous_vars[1], y = continuous_vars[2]) +
    scale_color_gradient(low = "blue", high = "red") +
    theme_minimal()

  density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
    geom_density(fill = "blue", alpha = 0.5) +
    labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
    theme_minimal() +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

  density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
    geom_density(fill = "red", alpha = 0.5) +
    coord_flip() +
    labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
    theme_minimal() +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())

  final_plot_2d <- (density_x + plot_spacer()) /
                   (scatter_plot + density_y) +
                   plot_layout(widths = c(4, 1), heights = c(1, 4))

  return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  # Modelovanie zdruzenej hustoty ako hustoty normalneho rozdelenia a pomocou kopuly (rozklad na marginaly)
  if (model_type == "normal") {
    # Vypocet marginalnych parametrov
  mean_x <- mean(data[[continuous_vars[1]]], na.rm = TRUE)
  sd_x <- sd(data[[continuous_vars[1]]], na.rm = TRUE)
  mean_y <- mean(data[[continuous_vars[2]]], na.rm = TRUE)
  sd_y <- sd(data[[continuous_vars[2]]], na.rm = TRUE)

  # Vypocet hodnoty marginalnych rozdeleni pre vstup do kopuly
  u1 <- pnorm(data[[continuous_vars[1]]], mean = mean_x, sd = sd_x)
  u2 <- pnorm(data[[continuous_vars[2]]], mean = mean_y, sd = sd_y)

  if (copula_type == "Clayton") {
    copula_model <- claytonCopula(param = 2, dim = 2)
  } else if (copula_type == "Gumbel") {
    copula_model <- gumbelCopula(param = 2, dim = 2)
  } else if (copula_type == "Frank") {
    copula_model <- frankCopula(param = 5, dim = 2)
  } else {
    stop("Zadaný 'copula_type' nie je podporovaný. Použi: 'Clayton', 'Gumbel', 'Frank'.")
  }

  # Fitovanie kopuly na marginálne transformované dáta
  copula_fit <- fitCopula(copula_model, pobs(cbind(u1, u2)), method = "ml")
  copula_model_fitted <- copula_fit@copula

  # Vytvorenie gridu pre hustotu
  x_vals <- seq(min(data[[continuous_vars[1]]], na.rm = TRUE), max(data[[continuous_vars[1]]], na.rm = TRUE), length.out = 100)
  y_vals <- seq(min(data[[continuous_vars[2]]], na.rm = TRUE), max(data[[continuous_vars[2]]], na.rm = TRUE), length.out = 100)

  grid <- expand.grid(x = x_vals, y = y_vals)

  # Vypocet zdruzenej hustoty cez rozklad na marginaly + kopula
  copula_density_function <- function(x, y) {
    u1 <- pnorm(x, mean = mean_x, sd = sd_x)
    u2 <- pnorm(y, mean = mean_y, sd = sd_y)

    copula_part <- dCopula(cbind(u1, u2), copula = copula_model_fitted)

    marginal_x <- dnorm(x, mean = mean_x, sd = sd_x)
    marginal_y <- dnorm(y, mean = mean_y, sd = sd_y)

    copula_part * marginal_x * marginal_y
  }

  # Vypocet hustoty na sieti
  grid$z <- mapply(copula_density_function, grid$x, grid$y)
  z_matrix <- matrix(grid$z, nrow = 100, byrow = FALSE)

  # 3D Vizualizacia
  fig_3d <- plot_ly(
    x = ~x_vals, y = ~y_vals, z = ~z_matrix,
    type = "surface",
    colors = colorRamp(c("blue", "cyan", "yellow", "red"))
  ) %>% layout(
    title = paste0("Združená hustota ", continuous_vars[1], " a ", continuous_vars[2], " (dnorm + ", copula_type, " kopula)"),
    scene = list(
      xaxis = list(title = continuous_vars[1]),
      yaxis = list(title = continuous_vars[2]),
      zaxis = list(title = "Hustota")
    )
  )

  # 2D Vizualizacia
  scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
    geom_point(size = 3, alpha = 0.7) +  
    labs(x = continuous_vars[1], y = continuous_vars[2]) +
    scale_color_gradient(low = "blue", high = "red") +
    theme_minimal()

  density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
    stat_function(fun = dnorm, args = list(mean = mean_x, sd = sd_x), fill = "blue", geom = "area", alpha = 0.5) +
    labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
    theme_minimal() +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())

  density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
    stat_function(fun = dnorm, args = list(mean = mean_y, sd = sd_y), fill = "red", geom = "area", alpha = 0.5) +
    coord_flip() +
    labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
    theme_minimal() +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())

  final_plot_2d <- (density_x + plot_spacer()) /
                   (scatter_plot + density_y) +
                   plot_layout(widths = c(4, 1), heights = c(1, 4))

  return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
  
  # Modelovanie zdruzenej hustoty ako hustoty Studentovho t-rozdelenia a pomocou kopuly (rozklad na marginaly)
  if (model_type == "t") {
    # Vypocet zakladnych parametrov marginalnych Studentovych t-rozdeleni
    mean_x <- mean(data[[continuous_vars[1]]], na.rm = TRUE)
    sd_x <- sd(data[[continuous_vars[1]]], na.rm = TRUE)
    mean_y <- mean(data[[continuous_vars[2]]], na.rm = TRUE)
    sd_y <- sd(data[[continuous_vars[2]]], na.rm = TRUE)
  
    # Stupne volnosti marginal
    df <- nrow(data) - 1
    if (df < 2) df <- 2
  
    # Hodnoty marginalnych distribucnych funkcii
    u1 <- pt((data[[continuous_vars[1]]] - mean_x) / sd_x, df = df)
    u2 <- pt((data[[continuous_vars[2]]] - mean_y) / sd_y, df = df)
  
    if (copula_type == "Clayton") {
      copula_model <- claytonCopula(param = 2, dim = 2)
    } else if (copula_type == "Gumbel") {
      copula_model <- gumbelCopula(param = 2, dim = 2)
    } else if (copula_type == "Joe") {
      copula_model <- joeCopula(param = 2, dim = 2)
    } else {
      stop("Zadaný 'copula_type' nie je podporovaný. Použi: 'Clayton', 'Gumbel', 'Joe'.")
    }
  
    # Fitovanie kopuly na marginalne transformovane data
    copula_fit <- fitCopula(copula_model, pobs(cbind(u1, u2)), method = "ml")
    copula_model_fitted <- copula_fit@copula
  
    # Vytvorenie siete pre vypocet hustoty
    x_vals <- seq(min(data[[continuous_vars[1]]], na.rm = TRUE), max(data[[continuous_vars[1]]], na.rm = TRUE), length.out = 100)
    y_vals <- seq(min(data[[continuous_vars[2]]], na.rm = TRUE), max(data[[continuous_vars[2]]], na.rm = TRUE), length.out = 100)
  
    grid <- expand.grid(x = x_vals, y = y_vals)
  
    # Funkcia pre vypocet zdruzenej hustoty
    copula_density_function <- function(x, y) {
      u1 <- pt((x - mean_x) / sd_x, df = df)
      u2 <- pt((y - mean_y) / sd_y, df = df)
  
      copula_part <- dCopula(cbind(u1, u2), copula = copula_model_fitted)
  
      marginal_x <- dt((x - mean_x) / sd_x, df = df) / sd_x
      marginal_y <- dt((y - mean_y) / sd_y, df = df) / sd_y
  
      copula_part * marginal_x * marginal_y
    }
  
    # Vypocet hustoty na sieti
    grid$z <- mapply(copula_density_function, grid$x, grid$y)
    z_matrix <- matrix(grid$z, nrow = 100, byrow = FALSE)
  
    # 3D Vizualizacia
    fig_3d <- plot_ly(
      x = ~x_vals, y = ~y_vals, z = ~z_matrix,
      type = "surface",
      colors = colorRamp(c("blue", "cyan", "yellow", "red"))
    ) %>% layout(
      title = paste("Združená hustota", continuous_vars[1], "a", continuous_vars[2], paste0("(t-rozdelenie + ", copula_type, " kopula)")),
      scene = list(
        xaxis = list(title = continuous_vars[1]),
        yaxis = list(title = continuous_vars[2]),
        zaxis = list(title = "Hustota")
      )
    )
  
    # 2D Vizualizacia
    scatter_plot <- ggplot(data, aes_string(x = continuous_vars[1], y = continuous_vars[2], color = continuous_vars[2])) +
      geom_point(size = 3, alpha = 0.7) +  
      labs(x = continuous_vars[1], y = continuous_vars[2]) +
      scale_color_gradient(low = "blue", high = "red") +
      theme_minimal()
  
    density_x <- ggplot(data, aes_string(x = continuous_vars[1])) +
      stat_function(fun = function(x) dt((x - mean_x) / sd_x, df = df) / sd_x, fill = "blue", geom = "area", alpha = 0.5) +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[1], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
    density_y <- ggplot(data, aes_string(x = continuous_vars[2])) +
      stat_function(fun = function(y) dt((y - mean_y) / sd_y, df = df) / sd_y, fill = "red", geom = "area", alpha = 0.5) +
      coord_flip() +
      labs(x = NULL, y = paste("Hustota (", continuous_vars[2], ")", sep = "")) +
      theme_minimal() +
      theme(axis.text.y = element_blank(), axis.ticks.y = element_blank())
  
    final_plot_2d <- (density_x + plot_spacer()) /
                     (scatter_plot + density_y) +
                     plot_layout(widths = c(4, 1), heights = c(1, 4))
  
    return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
  }
}
```

# Modelovanie zdruzeneho rozdelenia pravdepodobnosti viac ako 2 premennych

```{r,warning=FALSE}
multi_joint_distribution <- function(data, discrete_vars, continuous_vars) {
  
  # Vytvorenie tabulky s frekvenciami pre diskretne premenne
  tab <- as.data.frame(table(data[, discrete_vars]))
  
  # Pre kazdu spojitu premennu vypocitame priemerne hodnoty pre kombinacie diskretnych premennych
  for (cont_var in continuous_vars) {
    mean_values <- data %>%
      group_by(across(all_of(discrete_vars))) %>%
      summarise(Mean_Value = mean(.data[[cont_var]], na.rm = TRUE), .groups = "drop")
    
    # mean_values neobsahuje ziadne riadky => preskocime tuto premennu
    if (nrow(mean_values) == 0) {
      warning(paste("Žiadne dáta na výpočet priemeru pre premennú:", cont_var))
      next
    }
    
    # Overenie, ktore diskretne premenne existuju v tab a mean_values
    common_vars <- intersect(names(tab), discrete_vars)
    common_vars_mv <- intersect(names(mean_values), discrete_vars)
    
    # Existuju spolocne premenne => prevedenie na character
    if (length(common_vars) > 0) {
      tab <- tab %>%
        mutate(across(all_of(common_vars), as.character))
    }
    if (length(common_vars_mv) > 0) {
      mean_values <- mean_values %>%
        mutate(across(all_of(common_vars_mv), as.character))
    }
    
    # Spojenie priemernych hodnot so zakladnou tabulkou
    tab <- full_join(tab, mean_values, by = common_vars)
    
    # Premenovanie stlpca Mean_Value na nazov spojitej premennej
    colnames(tab)[which(colnames(tab) == "Mean_Value")] <- cont_var
  }
  
  # Náhrada NA vo Frequency nulami
  tab$Freq[is.na(tab$Freq)] <- 0
  
  # Vypocet pravdepodobnosti
  tab$Probability <- tab$Freq / sum(tab$Freq)
  
  # Odstranenie riadkov s nulovou frekvenciou
  tab <- tab[tab$Freq > 0, ]
  
  return(tab)
}
```

# Modelovanie dvoch dikretnych nahodnych premennych

```{r,warning=FALSE}
discrete_joint_distribution <- function(data, discrete_vars) {
  
  tab <- as.data.frame(table(data[, discrete_vars]))
  tab$Probability <- tab$Freq / sum(tab$Freq)

  tab[[discrete_vars[1]]] <- as.numeric(as.character(tab[[discrete_vars[1]]]))
  tab[[discrete_vars[2]]] <- as.numeric(as.character(tab[[discrete_vars[2]]]))

  # 3D Vizualizacia
  fig_3d <- plot_ly()
  for (i in 1:nrow(tab)) {
      fig_3d <- fig_3d %>% add_trace(
          x = rep(tab[[discrete_vars[1]]][i], 2),
          y = rep(tab[[discrete_vars[2]]][i], 2),
          z = c(0, tab$Probability[i]),
          type = "scatter3d",
          mode = "lines",
          line = list(color = "blue"),
          showlegend = FALSE
      )
  }

  fig_3d <- fig_3d %>% add_trace(
      x = tab[[discrete_vars[1]]],
      y = tab[[discrete_vars[2]]],
      z = tab$Probability,
      type = "scatter3d",
      mode = "markers",
      marker = list(size = 5, color = "red"),
      name = "Pravdepodobnosti"
  )

  fig_3d <- fig_3d %>% layout(
      scene = list(
          xaxis = list(title = paste0(discrete_vars[1], " (X)")),
          yaxis = list(title = paste0(discrete_vars[2], " (Y)")),
          zaxis = list(title = "P(X, Y)")
      )
  )

    marginal_x <- tab %>%
  group_by(!!sym(discrete_vars[1])) %>%
  summarise(Prob_X = sum(Probability))

  marginal_y <- tab %>%
    group_by(!!sym(discrete_vars[2])) %>%
    summarise(Prob_Y = sum(Probability))
  
  # 2D Vizualizacia
  scatter_plot <- ggplot(tab, aes_string(x = discrete_vars[1], y = discrete_vars[2], fill =   "Probability")) +
    geom_tile(color = "white") +
    scale_fill_gradient(low = "blue", high = "red") +
    labs(x = discrete_vars[1], y = discrete_vars[2], fill = "Pravdepodobnosť") +
    theme_minimal()
  
  marginal_x_plot <- ggplot(marginal_x, aes_string(x = discrete_vars[1], y = "Prob_X")) +
    geom_bar(stat = "identity", fill = "blue", alpha = 0.6) +
    labs(x = NULL, y = "P(X)") +
    theme_minimal()
  
  marginal_y_plot <- ggplot(marginal_y, aes_string(x = discrete_vars[2], y = "Prob_Y")) +
    geom_bar(stat = "identity", fill = "red", alpha = 0.6) +
    coord_flip() +
    labs(x = NULL, y = "P(Y)") +
    theme_minimal()
  
  final_plot_2d <- (marginal_x_plot + plot_spacer()) /
                   (scatter_plot + marginal_y_plot) +
                   plot_layout(widths = c(4, 1), heights = c(1, 4))

  return(list(fig_3d = fig_3d, final_plot_2d = final_plot_2d))
}
```

# Modelovanie združeného rozdelenia pravdepodobnosti (Hustota)

```{r, warning=FALSE}
model_joint_distribution_density <- function(data, selected_variables, model_type = NULL, copula = FALSE, copula_type = NULL, bw = NULL) {
  # Identifikacia typov premennych
  variable_types <- identify_variables(data)
  discrete_vars <- intersect(variable_types$Diskretne, selected_variables)
  continuous_vars <- intersect(variable_types$Spojite, selected_variables)
  variables_count <- length(discrete_vars) + length(continuous_vars)
  
  if (length(selected_variables) == 2 && length(continuous_vars) == 0) {
    if (!is.null(model_type) || copula != FALSE || !is.null(copula_type)) {
      stop("Argumenty model_type, 'copula' a 'copula_type' sa nepouzivaju pri modelovani dvoch diskretnych premennych.")
    }
    result <- discrete_joint_distribution(data, discrete_vars)
    print(result)
  } else if (variables_count > 2) {
    if (!is.null(model_type) || copula != FALSE || !is.null(copula_type)) {
      stop("Argumenty model_type, 'copula' a 'copula_type' sa nepouzivaju pri modelovani vacsieho poctu premennych ako 2.")
    }
    result <- multi_joint_distribution(data, discrete_vars, continuous_vars)
    print(result)
  } else if (length(selected_variables) == 2 && length(discrete_vars) == 0) {
    if (copula == FALSE) {
      if (!is.null(copula_type)) {
        stop("Argument 'copula_type' mozno pouzit len ked 'copula' = 'TRUE'.")
      }
      else {
        result <- continuous_joint_distribution(data, continuous_vars, model_type)
        print(result)
      }
    }
    else {
      if (is.null(copula_type)) {
        stop("Ak je 'copula' = 'TRUE', musi byt specifikovany aj parameter 'copula_type'.")
      }
      else {
        result <- continuous_joint_distribution_copula(data, continuous_vars, model_type, copula_type)
        print(result)
      }
    }
  } else if (length(selected_variables) == 2 && length(discrete_vars) == 1) {
    if (copula != FALSE || !is.null(copula_type)) {
      stop("Argumenty 'copula' a 'copula_type' sa pouzivaju iba pri modelovani dvoch spojitych premennych.")
    }
    result <- mixture_joint_distribution(data, discrete_vars, continuous_vars, model_type, bw)
    print(result)
  }
}
```

# Modelovanie podmienenej strednej hodnoty a kvantilovej funkcie (regresia)

```{r, warning=FALSE}
model_conditional_mean_value <- function(data, selected_variables, mean_method = "linear", quantile_method = "linear", poly_mean_degree = NULL, poly_quant_degree = NULL, quantiles = 0.5, specific_x = NULL) {
  
  if (length(selected_variables) != 2) {
    return(NULL)
  }
  
  response_name <- selected_variables[1]
  predictor_name <- selected_variables[2]
  
  if (mean_method == "poly" && is.null(poly_mean_degree)) {
    stop("Pri pouziti mean_method = 'poly' je potrebne zadat aj poly_mean_degree!")
  }
  
  if (!is.null(poly_mean_degree) && mean_method != "poly") {
    stop("poly_mean_degree sa pouziva iba pri mean_method = 'poly'.")
  }
  
  if (quantile_method == "poly" && is.null(poly_quant_degree)) {
    stop("Pri pouziti quantile_method = 'poly' je potrebne zadat aj poly_quant_degree!")
  }
  
  if (!is.null(poly_quant_degree) && quantile_method != "poly") {
    stop("poly_quant_degree sa pouziva iba pri quantile_method = 'poly'.")
  }
  
  variable_types <- identify_variables(data)

  if (!(response_name %in% colnames(data))) {
    stop(paste("Premenna", response_name, "nie je v datach!"))
  }

  if (!(predictor_name %in% colnames(data))) {
    stop(paste("Premenna", predictor_name, "nie je v datach!"))
  }

  if (!(response_name %in% c(variable_types$Spojite, variable_types$Diskretne))) {
    stop(paste("Premenna", response_name, "nie je rozpoznana ako spojita ani diskretna."))
  }

  if (!(predictor_name %in% variable_types$Spojite)) {
    stop(paste("Prediktor", predictor_name, "musi byt spojita premenna!"))
  }

  response <- data[[response_name]]
  predictor <- data[[predictor_name]]

  # X sekvencia pre predikcie
  x_seq <- seq(min(predictor), max(predictor), length.out = 200)

  # Odhad podmienenej strednej hodnoty E[Y|X] podla metody
  if (mean_method == "loess") {
    loess_fit <- loess(response ~ predictor, span = 0.75)
    mean_pred <- predict(loess_fit, newdata = data.frame(predictor = x_seq))
  } else if (mean_method == "gam") {
    gam_fit <- gam(response ~ s(predictor))
    mean_pred <- predict(gam_fit, newdata = data.frame(predictor = x_seq))
  } else if (mean_method == "spline") {
    spline_fit <- lm(response ~ bs(predictor, df = 5))
    mean_pred <- predict(spline_fit, newdata = data.frame(predictor = x_seq))
  } else if (mean_method == "linear") {
    lm_fit <- lm(response ~ predictor)
    mean_pred <- predict(lm_fit, newdata = data.frame(predictor = x_seq))

  } else if (mean_method == "poly") {
    poly_fit <- lm(response ~ poly(predictor, degree = poly_mean_degree, raw = TRUE))
    mean_pred <- predict(poly_fit, newdata = data.frame(predictor = x_seq))

  } else if (mean_method == "exp") {
    nls_fit <- nls(response ~ a * exp(b * predictor), 
                   start = list(a = 1, b = 0.01))
    mean_pred <- predict(nls_fit, newdata = data.frame(predictor = x_seq))

  } else {
    stop("Neplatna metoda mean_method! Vyber: 'loess', 'gam', 'spline', 'linear', 'poly', alebo 'exp'.")
  }

  # Odhad podmienenej kvantilovej funkcie pre viac kvantilov
  quantile_preds <- list()

  for (q in quantiles) {
    
    if (quantile_method == "linear") {
      rq_fit <- rq(response ~ predictor, tau = q)
      
    } else if (quantile_method == "poly") {
      rq_fit <- rq(response ~ poly(predictor, degree = poly_quant_degree, raw = TRUE), tau = q)
      
    } else if (quantile_method == "spline") {
      rq_fit <- rq(response ~ ns(predictor, df = 4), tau = q)
      
    } else {
      stop("Neplatna quantile_method! Vyber: 'linear', 'poly', alebo 'spline'.")
    }
    
    quantile_preds[[as.character(q)]] <- predict(rq_fit, newdata = data.frame(predictor = x_seq))
  }

  if (is.null(specific_x)) {
    specific_x <- median(predictor, na.rm = TRUE)
  }

  # Predikcia pre konkretny bod X podla mean_method
  # Neparametricke modely
  if (mean_method == "loess") {
    specific_mean <- predict(loess_fit, newdata = data.frame(predictor = specific_x))
  } else if (mean_method == "gam") {
    specific_mean <- predict(gam_fit, newdata = data.frame(predictor = specific_x))
  } else if (mean_method == "spline") {
    specific_mean <- predict(spline_fit, newdata = data.frame(predictor = specific_x))
  } 
  # Parametricke modely
    else if (mean_method == "linear") {
    specific_mean <- predict(lm_fit, newdata = data.frame(predictor = specific_x))

  } else if (mean_method == "poly") {
    specific_mean <- predict(poly_fit, newdata = data.frame(predictor = specific_x))

  } else if (mean_method == "exp") {
    specific_mean <- predict(nls_fit, newdata = data.frame(predictor = specific_x))
  }

  # Kvantily pre konkretne X
  specific_quantiles <- list()

  for (q in quantiles) {
    
    if (quantile_method == "linear") {
      rq_fit <- rq(response ~ predictor, tau = q)
      
    } else if (quantile_method == "poly") {
      rq_fit <- rq(response ~ poly(predictor, degree = poly_quant_degree, raw = TRUE), tau = q)
      
    } else if (quantile_method == "spline") {
      rq_fit <- rq(response ~ ns(predictor, df = 4), tau = q)
      
    } else {
      stop("Neplatna quantile_method! Vyber: 'linear', 'poly', alebo 'spline'.")
    }
    
    specific_quantiles[[as.character(q)]] <- predict(rq_fit, newdata = data.frame(predictor = specific_x))
  }

  plot_data <- data.frame(
    X = x_seq,
    Mean = mean_pred
  )

  for (q in quantiles) {
    plot_data[[paste0("Quantile_", q)]] <- quantile_preds[[as.character(q)]]
  }

  p <- ggplot(data, aes_string(x = predictor_name, y = response_name)) +
    geom_point(alpha = 0.4, color = "darkgreen") +
    geom_line(data = plot_data, aes(x = X, y = Mean), color = "blue", size = 1.2, linetype = "solid") +
    labs(
      title = "Podmienená stredná hodnota a vybrané kvantilové funkcie",
      x = paste0(predictor_name, " (Prediktor)"),
      y = paste0(response_name, " (Odozva)")
    ) +
    theme_minimal()

  # Kvantilove krivky
  for (q in quantiles) {
    p <- p + geom_line(
      data = plot_data,
      aes_string(x = "X", y = paste0("Quantile_", q)),
      size = 1, linetype = "dashed", color = "red"
    )
  
    p <- p + geom_point(data = data.frame(specific_x = specific_x, y_val = specific_quantiles[[as.character(q)]]),
                      mapping = aes(x = specific_x, y = y_val),
                      color = "red", size = 3)

    q_label <- paste0("Q_", q, "(Y|X=", round(specific_x, 2), ")=", round(specific_quantiles[[as.character(q)]], 2))
    p <- p + annotate("text", 
                      x = specific_x, 
                      y = specific_quantiles[[as.character(q)]],
                      label = q_label, hjust = -0.1, color = "red")
  }
  
  p <- p + geom_point(data = data.frame(specific_x = specific_x, specific_mean = specific_mean),
                    mapping = aes(x = specific_x, y = specific_mean),
                    color = "blue", size = 3)

  label_text <- paste0("E[Y|X=", round(specific_x, 2), "]=", round(specific_mean, 2))
  p <- p + annotate("text", x = specific_x, y = specific_mean,
                    label = label_text, hjust = -0.1, color = "blue")

  return(list(
    plot = p,
    conditional_mean = data.frame(X = x_seq, E_Y_given_X = mean_pred),
    conditional_quantiles = dplyr::select(plot_data, X, dplyr::starts_with("Quantile_"))
  ))
}
```

```{r, warning=FALSE}
result <- model_conditional_mean_value(data, c("carb", "hp"), "poly", "poly", 2, 3, c(0.05, 0.95), 150)

result$plot
```

# Finálne výstupy
```{r, warning=FALSE}
printVariables(data)
model_joint_distribution_density(data, c("hp", "carb"), model_type = "normal")
```

# Dokumentacia

## Co dosadit za parametre do model_joint_distribution_density()

### Vyber kopuly [copula_type]

Normalne rozdelenie
- Clayton: param > 0 (cim vacsie, tym silnejsia zavislost v spodnom chvoste)
- Gumbel: param >= 1 (cim vacsie, tym silnejsia zavislost v hornom chvoste)
- Frank: param != 0 (kladne = pozitivna zavislost, zaporne = negativna zavislost)
Studentovo t-rozdelenie
- Clayton
- Gumbel
- Joe
Jadrove vyhladzovanie
- empirical
- Gumbel
- Frank

### Typy rozdeleni [model_type]
- normalne ["normal"]
- Studentovo t-rozdelenie ["t"]
- jadrovo vyhladene ["kernel"] - mozne zadat aj parameter bw (bandwidth), nezadany => automatizovane vyhladzovanie

## Co dosadit za parametre do model_conditional_mean_value()

### Premenne typu 'Odozva' a 'Prediktor'
- na vstup sa posielaju vzdy dve premenne vo forme c("Odozva", "Prediktor")

### Kvantily na vykreslenie
- moze byt jeden a viac
- ked chceme poslat viac => c(Q1, Q2, Q3, ...)
- ked chceme poslat jeden => napr. Q2

### Vyber metody pre odhad podmienenej strednej hodnoty E[Y|X]
- moznosti su:
  a) Neparametricke modely
    1. **"loess"** (Lokalna regresia, prisposobuje modely (linearne, kvadraticke) podla okolia (75% bodov))
    2. **"gam"** (Generalizacny aditivny model, scitava hladke funkcie)
    3. **"spline"** (podobne principu MKP)
  b) Parametricke modely
    1. **"linear"** (linearny regresny model)
    2. **"poly"** (polynomialny regresny model, zadava sa aj s parametrom poly_mean_degree = 1,2,3,..., pre *poly_mean_degree = 1* dava          *"linear"*)
    3. **"exp"** (exponencialny regresny model)
    
### Vyber metody pre odhad podmienenej kvantilovej funkcie
- moznosti su:
  a) Neparametricke modely
    1. **"spline"** (podobne principu MKP)
  b) Parametricke modely
    1. **"linear"** (linearny regresny model)
    2. **"poly"** (polynomialny regresny model, zadava sa aj s parametrom poly_quant_degree = 1,2,3,..., pre *poly_quant_degree = 1* dava          *"linear"*)
    
    
*Pridat*
- copula -> use_copula
- kernel - explicitne zadavat bw aj pre marginalu
- normal_copula - dat uzivatleovi moznost vyberu pocitania marginalnych hustot (napr. cez pnorm() alebo lognorm atd.)
- rozdelit funkciu model_conditional_mean_value na dve
- pridat funkciu na modelovanie klasikacnych metod (logisticka regresia)

